{"version":3,"sources":["ts/tests/bi-map.test.ts"],"names":["bi_map_1","require","describe","test","BiMap","bimap","beforeEach","set","expect","get","toBe","toBeUndefined","getFromKey","getFromValue"],"mappings":"oEAMA,MAAAA,SAAAC,QAAA,aAEAC,SAAS,iBAAkB,KAE1BC,KAAK,wBAAyB,KAEA,IAAIH,SAAAI,UAQnCF,SAAS,mBAAoB,KAE5B,IAAIG,EAEJC,WAAW,MAEVD,EAAQ,IAAIL,SAAAI,OAENG,IAAI,MAAO,GACjBF,EAAME,IAAI,MAAO,GACjBF,EAAME,IAAI,QAAS,KAIpBL,SAAS,OAAQ,KAEhBC,KAAK,6DAA2D,KAE/DK,OAAOH,EAAMI,IAAI,QAAQC,KAAK,GAC9BF,OAAOH,EAAMI,IAAI,QAAQC,KAAK,GAC9BF,OAAOH,EAAMI,IAAI,UAAUC,KAAK,KAIjCP,KAAK,uDAAwD,KAE5DK,OAAOH,EAAMI,IAAI,SAASE,gBAC1BH,OAAOH,EAAMI,IAAI,SAASE,oBAM5BT,SAAS,OAAQ,KAEhBC,KAAK,mCAAoC,KAExCE,EAAME,IAAI,OAAQ,KAInBJ,KAAK,8CAA+C,KAEnDE,EAAME,IAAI,OAAQ,GAClBC,OAAOH,EAAMO,WAAW,SAASF,KAAK,GACtCF,OAAOH,EAAMQ,aAAa,IAAIH,KAAK,UAIpCP,KAAK,8DAA+D,KAEnEE,EAAME,IAAI,MAAO,IACjBC,OAAOH,EAAMO,WAAW,QAAQF,KAAK,IACrCF,OAAOH,EAAMQ,aAAa,KAAKH,KAAK,OACpCF,OAAOH,EAAMQ,aAAa,IAAIF,oBAMhCT,SAAS,cAAe,KAEvBC,KAAK,6DAA2D,KAE/DK,OAAOH,EAAMO,WAAW,QAAQF,KAAK,GACrCF,OAAOH,EAAMO,WAAW,QAAQF,KAAK,GACrCF,OAAOH,EAAMO,WAAW,UAAUF,KAAK,KAIxCP,KAAK,uDAAwD,KAE5DK,OAAOH,EAAMO,WAAW,SAASD,gBACjCH,OAAOH,EAAMO,WAAW,SAASD,oBAMnCT,SAAS,gBAAiB,KAEzBC,KAAK,GAAI,UAQVD,SAAS,cAAe,QAMxBA,SAAS,gBAAiB,QAM1BA,SAAS,eAAgB,QAMzBA,SAAS,iBAAkB,QAM3BA,SAAS,UAAW,QAMpBA,SAAS,YAAa,QAMtBA,SAAS,SAAU","file":"bi-map.test.js","sourcesContent":["/*\n *\tCreated by Trevor Sears <trevorsears.main@gmail.com>.\n *\t11:14 AM -- September 18th, 2019.\n *\tProject: @jsdsl/bimap\n */\n\nimport { BiMap } from \"../bi-map\";\n\ndescribe(\"Initialization\", () => {\n\t\n\ttest(\"Basic initialization.\", () => {\n\t\t\n\t\tlet bimap: BiMap<any, any> = new BiMap<any, any>();\n\t\t\n\t\tbimap;\n\t\t\n\t});\n\t\n});\n\ndescribe(\"Per-method Tests\", () => {\n\t\n\tlet bimap: BiMap<string, number>;\n\t\n\tbeforeEach(() => {\n\t\t\n\t\tbimap = new BiMap<string, number>();\n\t\t\n\t\tbimap.set(\"one\", 1);\n\t\tbimap.set(\"two\", 2);\n\t\tbimap.set(\"three\", 3);\n\t\t\n\t});\n\t\n\tdescribe(\"#get\", () => {\n\t\t\n\t\ttest(\"Regular key --> value retrieval returns expected value.\", () => {\n\t\t\t\n\t\t\texpect(bimap.get(\"one\")).toBe(1);\n\t\t\texpect(bimap.get(\"two\")).toBe(2);\n\t\t\texpect(bimap.get(\"three\")).toBe(3);\n\t\t\t\n\t\t});\n\t\t\n\t\ttest(\"Attempt to get non-existent value returns undefined.\", () => {\n\t\t\n\t\t\texpect(bimap.get(\"zero\")).toBeUndefined();\n\t\t\texpect(bimap.get(\"four\")).toBeUndefined();\n\t\t\n\t\t});\n\t\t\n\t});\n\t\n\tdescribe(\"#set\", () => {\n\t\n\t\ttest(\"Regular set does not error/fail.\", () => {\n\t\t\t\n\t\t\tbimap.set(\"four\", 4);\n\t\t\t\n\t\t});\n\t\t\n\t\ttest(\"Set-get relationship is properly reflexive.\", () => {\n\t\t\t\n\t\t\tbimap.set(\"five\", 5);\n\t\t\texpect(bimap.getFromKey(\"five\")).toBe(5);\n\t\t\texpect(bimap.getFromValue(5)).toBe(\"five\");\n\t\t\t\n\t\t});\n\t\t\n\t\ttest(\"Set operation successfully overwrites previously held keys.\", () => {\n\t\t\t\n\t\t\tbimap.set(\"two\", 10);\n\t\t\texpect(bimap.getFromKey(\"two\")).toBe(10);\n\t\t\texpect(bimap.getFromValue(10)).toBe(\"two\");\n\t\t\texpect(bimap.getFromValue(2)).toBeUndefined();\n\t\t\t\n\t\t});\n\t\n\t});\n\t\n\tdescribe(\"#getFromKey\", () => {\n\t\t\n\t\ttest(\"Regular key --> value retrieval returns expected value.\", () => {\n\t\t\t\n\t\t\texpect(bimap.getFromKey(\"one\")).toBe(1);\n\t\t\texpect(bimap.getFromKey(\"two\")).toBe(2);\n\t\t\texpect(bimap.getFromKey(\"three\")).toBe(3);\n\t\t\t\n\t\t});\n\t\t\n\t\ttest(\"Attempt to get non-existent value returns undefined.\", () => {\n\t\t\t\n\t\t\texpect(bimap.getFromKey(\"zero\")).toBeUndefined();\n\t\t\texpect(bimap.getFromKey(\"four\")).toBeUndefined();\n\t\t\t\n\t\t});\n\t\n\t});\n\t\n\tdescribe(\"#getFromValue\", () => {\n\t\n\t\ttest(\"\", () => {\n\t\t\n\t\t\n\t\t\n\t\t});\n\t\n\t});\n\t\n\tdescribe(\"#setFromKey\", () => {\n\t\n\t\n\t\n\t});\n\t\n\tdescribe(\"#setFromValue\", () => {\n\t\n\t\n\t\n\t});\n\t\n\tdescribe(\"#removeByKey\", () => {\n\t\n\t\n\t\n\t});\n\t\n\tdescribe(\"#removeByValue\", () => {\n\t\n\t\n\t\n\t});\n\t\n\tdescribe(\"#hasKey\", () => {\n\t\n\t\n\t\n\t});\n\t\n\tdescribe(\"#hasValue\", () => {\n\t\n\t\n\t\n\t});\n\t\n\tdescribe(\"#clear\", () => {\n\t\n\t\n\t\n\t});\n\t\n});"]}